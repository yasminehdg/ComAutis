<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üåÄ Labyrinthe - ComAutiste</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Comic Sans MS', 'Arial Rounded MT Bold', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1000px;
            margin: 0 auto;
        }

        .header {
            background: white;
            padding: 30px;
            border-radius: 25px;
            text-align: center;
            margin-bottom: 30px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.15);
            animation: slideDown 0.6s ease-out;
        }

        @keyframes slideDown {
            from { opacity: 0; transform: translateY(-30px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .header h1 {
            font-size: 42px;
            color: #2c3e50;
            margin-bottom: 10px;
        }

        .header p {
            font-size: 20px;
            color: #7f8c8d;
        }

        .difficulty-selector {
            background: white;
            padding: 25px;
            border-radius: 20px;
            margin-bottom: 25px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
            text-align: center;
        }

        .difficulty-selector h3 {
            font-size: 22px;
            color: #2c3e50;
            margin-bottom: 15px;
        }

        .difficulty-buttons {
            display: flex;
            gap: 15px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .difficulty-btn {
            padding: 15px 30px;
            border: 3px solid #e0e0e0;
            border-radius: 15px;
            background: white;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            font-family: 'Comic Sans MS', sans-serif;
        }

        .difficulty-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }

        .difficulty-btn.active {
            border-color: #667eea;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .game-info {
            display: flex;
            justify-content: space-around;
            background: white;
            padding: 20px;
            border-radius: 20px;
            margin-bottom: 25px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }

        .info-item {
            text-align: center;
        }

        .info-label {
            font-size: 16px;
            color: #7f8c8d;
            margin-bottom: 5px;
        }

        .info-value {
            font-size: 32px;
            font-weight: bold;
            color: #2c3e50;
        }

        .game-container {
            background: white;
            padding: 30px;
            border-radius: 25px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.15);
            margin-bottom: 25px;
        }

        #maze-canvas {
            display: block;
            margin: 0 auto;
            border-radius: 15px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
            touch-action: none;
        }

        .controls {
            display: flex;
            gap: 15px;
            justify-content: center;
            flex-wrap: wrap;
            margin-top: 20px;
        }

        .btn {
            padding: 15px 40px;
            border: none;
            border-radius: 50px;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
            font-family: 'Comic Sans MS', sans-serif;
        }

        .btn-restart {
            background: linear-gradient(135deg, #ff6b9d 0%, #ff8e53 100%);
            color: white;
        }

        .btn-restart:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 20px rgba(255, 107, 157, 0.4);
        }

        .btn-hint {
            background: linear-gradient(135deg, #feca57 0%, #ff9ff3 100%);
            color: white;
        }

        .btn-hint:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 20px rgba(254, 202, 87, 0.4);
        }

        .btn-back {
            background: white;
            color: #2c3e50;
            border: 3px solid #2c3e50;
        }

        .btn-back:hover {
            background: #2c3e50;
            color: white;
            transform: translateY(-3px);
        }

        .arrow-controls {
            background: white;
            padding: 20px;
            border-radius: 20px;
            margin-bottom: 25px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }

        .arrow-controls h3 {
            text-align: center;
            font-size: 20px;
            color: #2c3e50;
            margin-bottom: 15px;
        }

        .arrow-grid {
            display: grid;
            grid-template-columns: repeat(3, 80px);
            gap: 10px;
            justify-content: center;
        }

        .arrow-btn {
            width: 80px;
            height: 80px;
            border: 3px solid #667eea;
            border-radius: 15px;
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            font-size: 32px;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: 'Comic Sans MS', sans-serif;
        }

        .arrow-btn:hover {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            transform: scale(1.1);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .arrow-btn:active {
            transform: scale(0.95);
        }

        .arrow-btn.empty {
            visibility: hidden;
        }

        .victory-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }

        .victory-content {
            background: white;
            padding: 50px;
            border-radius: 30px;
            text-align: center;
            max-width: 500px;
            animation: bounceIn 0.6s ease-out;
        }

        @keyframes bounceIn {
            0% { transform: scale(0); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }

        .victory-emoji {
            font-size: 100px;
            margin-bottom: 20px;
            animation: spin 2s ease-in-out infinite;
        }

        @keyframes spin {
            0%, 100% { transform: rotate(0deg); }
            50% { transform: rotate(360deg); }
        }

        .victory-content h2 {
            font-size: 48px;
            color: #27ae60;
            margin-bottom: 20px;
        }

        .victory-content p {
            font-size: 24px;
            color: #7f8c8d;
            margin-bottom: 15px;
        }

        .stars {
            font-size: 50px;
            margin: 20px 0;
        }

        @media (max-width: 768px) {
            .container {
                padding: 0 10px;
            }

            .header h1 {
                font-size: 32px;
            }

            #maze-canvas {
                max-width: 100%;
            }

            .controls {
                flex-direction: column;
            }

            .btn {
                width: 100%;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üåÄ Jeu Labyrinthe üåÄ</h1>
            <p>Guide la balle jusqu'√† la sortie !</p>
        </div>

        <div class="difficulty-selector">
            <h3>üéØ Choisis ta difficult√©</h3>
            <div class="difficulty-buttons">
                <button class="difficulty-btn active" data-size="10">üòä Facile (10x10)</button>
                <button class="difficulty-btn" data-size="15">ü§î Moyen (15x15)</button>
                <button class="difficulty-btn" data-size="20">üî• Difficile (20x20)</button>
            </div>
        </div>

        <div class="game-info">
            <div class="info-item">
                <div class="info-label">‚è±Ô∏è Temps</div>
                <div class="info-value" id="time">0s</div>
            </div>
            <div class="info-item">
                <div class="info-label">üë£ Pas</div>
                <div class="info-value" id="steps">0</div>
            </div>
            <div class="info-item">
                <div class="info-label">üéØ Niveau</div>
                <div class="info-value" id="level">1</div>
            </div>
        </div>

        <div class="game-container">
            <canvas id="maze-canvas"></canvas>
        </div>

        <div class="arrow-controls">
            <h3>üéÆ Utilise les fl√®ches pour te d√©placer</h3>
            <div class="arrow-grid">
                <div class="arrow-btn empty"></div>
                <button class="arrow-btn" onclick="movePlayer('up')">‚¨ÜÔ∏è</button>
                <div class="arrow-btn empty"></div>
                <button class="arrow-btn" onclick="movePlayer('left')">‚¨ÖÔ∏è</button>
                <div class="arrow-btn empty"></div>
                <button class="arrow-btn" onclick="movePlayer('right')">‚û°Ô∏è</button>
                <div class="arrow-btn empty"></div>
                <button class="arrow-btn" onclick="movePlayer('down')">‚¨áÔ∏è</button>
                <div class="arrow-btn empty"></div>
            </div>
        </div>

        <div class="controls">
            <button class="btn btn-restart" onclick="generateNewMaze()">üîÑ Nouveau Labyrinthe</button>
            <button class="btn btn-hint" onclick="showHint()">üí° Indice</button>
            <button class="btn btn-back" onclick="window.history.back()">‚¨ÖÔ∏è Retour</button>
        </div>
    </div>

    <div class="victory-modal" id="victory-modal">
        <div class="victory-content">
            <div class="victory-emoji">üéâ</div>
            <h2>Bravo !</h2>
            <p>Tu as trouv√© la sortie !</p>
            <div class="stars" id="stars"></div>
            <p><strong>‚è±Ô∏è Temps :</strong> <span id="final-time"></span></p>
            <p><strong>üë£ Pas :</strong> <span id="final-steps"></span></p>
            <button class="btn btn-restart" onclick="nextLevel()">‚û°Ô∏è Niveau Suivant</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('maze-canvas');
        const ctx = canvas.getContext('2d');

        let mazeSize = 10;
        let cellSize = 30;
        let maze = [];
        let player = { x: 0, y: 0 };
        let exit = { x: 0, y: 0 };
        let steps = 0;
        let timer = 0;
        let timerInterval = null;
        let level = 1;
        let path = [];
        let showingHint = false;

        // Couleurs
        const COLORS = {
            wall: '#2c3e50',
            path: '#ecf0f1',
            player: '#3498db',
            exit: '#27ae60',
            hint: '#feca57',
            visited: '#e8f4f8'
        };

        // Initialisation
        function init() {
            canvas.width = mazeSize * cellSize;
            canvas.height = mazeSize * cellSize;
            generateNewMaze();
        }

        // G√©n√©rer un nouveau labyrinthe
        function generateNewMaze() {
            steps = 0;
            timer = 0;
            document.getElementById('steps').textContent = '0';
            document.getElementById('time').textContent = '0s';
            
            clearInterval(timerInterval);
            timerInterval = setInterval(() => {
                timer++;
                document.getElementById('time').textContent = timer + 's';
            }, 1000);

            // Cr√©er la grille
            maze = [];
            for (let y = 0; y < mazeSize; y++) {
                maze[y] = [];
                for (let x = 0; x < mazeSize; x++) {
                    maze[y][x] = { visited: false, walls: [true, true, true, true] }; // haut, droite, bas, gauche
                }
            }

            // G√©n√©rer le labyrinthe avec l'algorithme de Prim
            const start = { x: 0, y: 0 };
            maze[start.y][start.x].visited = true;
            const walls = getWalls(start.x, start.y);

            while (walls.length > 0) {
                const wallIndex = Math.floor(Math.random() * walls.length);
                const wall = walls[wallIndex];
                walls.splice(wallIndex, 1);

                const [x1, y1, x2, y2, dir] = wall;

                if (!maze[y2][x2].visited) {
                    // Supprimer les murs
                    maze[y1][x1].walls[dir] = false;
                    maze[y2][x2].walls[(dir + 2) % 4] = false;

                    maze[y2][x2].visited = true;
                    walls.push(...getWalls(x2, y2));
                }
            }

            // Position du joueur (en haut √† gauche)
            player = { x: 0, y: 0 };
            
            // Position de la sortie (en bas √† droite)
            exit = { x: mazeSize - 1, y: mazeSize - 1 };

            // Calculer le chemin optimal
            calculatePath();

            draw();
        }

        function getWalls(x, y) {
            const walls = [];
            const directions = [
                [0, -1, 0], // haut
                [1, 0, 1],  // droite
                [0, 1, 2],  // bas
                [-1, 0, 3]  // gauche
            ];

            for (const [dx, dy, dir] of directions) {
                const newX = x + dx;
                const newY = y + dy;

                if (newX >= 0 && newX < mazeSize && newY >= 0 && newY < mazeSize) {
                    if (!maze[newY][newX].visited) {
                        walls.push([x, y, newX, newY, dir]);
                    }
                }
            }

            return walls;
        }

        // Calculer le chemin optimal (A*)
        function calculatePath() {
            const openSet = [{ x: player.x, y: player.y, g: 0, h: 0, parent: null }];
            const closedSet = new Set();
            path = [];

            while (openSet.length > 0) {
                openSet.sort((a, b) => (a.g + a.h) - (b.g + b.h));
                const current = openSet.shift();

                if (current.x === exit.x && current.y === exit.y) {
                    let node = current;
                    while (node) {
                        path.unshift({ x: node.x, y: node.y });
                        node = node.parent;
                    }
                    return;
                }

                closedSet.add(`${current.x},${current.y}`);

                const neighbors = getNeighbors(current.x, current.y);
                for (const neighbor of neighbors) {
                    const key = `${neighbor.x},${neighbor.y}`;
                    if (closedSet.has(key)) continue;

                    const g = current.g + 1;
                    const h = Math.abs(neighbor.x - exit.x) + Math.abs(neighbor.y - exit.y);
                    
                    const existing = openSet.find(n => n.x === neighbor.x && n.y === neighbor.y);
                    if (!existing || g < existing.g) {
                        if (existing) {
                            existing.g = g;
                            existing.parent = current;
                        } else {
                            openSet.push({ x: neighbor.x, y: neighbor.y, g, h, parent: current });
                        }
                    }
                }
            }
        }

        function getNeighbors(x, y) {
            const neighbors = [];
            const directions = [
                [0, -1, 0], // haut
                [1, 0, 1],  // droite
                [0, 1, 2],  // bas
                [-1, 0, 3]  // gauche
            ];

            for (const [dx, dy, dir] of directions) {
                if (!maze[y][x].walls[dir]) {
                    const newX = x + dx;
                    const newY = y + dy;
                    if (newX >= 0 && newX < mazeSize && newY >= 0 && newY < mazeSize) {
                        neighbors.push({ x: newX, y: newY });
                    }
                }
            }

            return neighbors;
        }

        // Dessiner le labyrinthe
        function draw() {
            ctx.fillStyle = COLORS.path;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Dessiner les murs
            ctx.strokeStyle = COLORS.wall;
            ctx.lineWidth = 3;

            for (let y = 0; y < mazeSize; y++) {
                for (let x = 0; x < mazeSize; x++) {
                    const cell = maze[y][x];
                    const px = x * cellSize;
                    const py = y * cellSize;

                    ctx.beginPath();
                    if (cell.walls[0]) { // haut
                        ctx.moveTo(px, py);
                        ctx.lineTo(px + cellSize, py);
                    }
                    if (cell.walls[1]) { // droite
                        ctx.moveTo(px + cellSize, py);
                        ctx.lineTo(px + cellSize, py + cellSize);
                    }
                    if (cell.walls[2]) { // bas
                        ctx.moveTo(px, py + cellSize);
                        ctx.lineTo(px + cellSize, py + cellSize);
                    }
                    if (cell.walls[3]) { // gauche
                        ctx.moveTo(px, py);
                        ctx.lineTo(px, py + cellSize);
                    }
                    ctx.stroke();
                }
            }

            // Dessiner l'indice si actif
            if (showingHint && path.length > 1) {
                ctx.strokeStyle = COLORS.hint;
                ctx.lineWidth = 5;
                ctx.lineCap = 'round';
                ctx.beginPath();
                for (let i = 0; i < Math.min(5, path.length); i++) {
                    const p = path[i];
                    const px = p.x * cellSize + cellSize / 2;
                    const py = p.y * cellSize + cellSize / 2;
                    if (i === 0) {
                        ctx.moveTo(px, py);
                    } else {
                        ctx.lineTo(px, py);
                    }
                }
                ctx.stroke();
            }

            // Dessiner la sortie
            ctx.fillStyle = COLORS.exit;
            ctx.beginPath();
            ctx.arc(
                exit.x * cellSize + cellSize / 2,
                exit.y * cellSize + cellSize / 2,
                cellSize / 3,
                0,
                Math.PI * 2
            );
            ctx.fill();
            ctx.fillStyle = 'white';
            ctx.font = 'bold 16px Comic Sans MS';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('üèÅ', exit.x * cellSize + cellSize / 2, exit.y * cellSize + cellSize / 2);

            // Dessiner le joueur
            ctx.fillStyle = COLORS.player;
            ctx.beginPath();
            ctx.arc(
                player.x * cellSize + cellSize / 2,
                player.y * cellSize + cellSize / 2,
                cellSize / 3,
                0,
                Math.PI * 2
            );
            ctx.fill();
            ctx.fillStyle = 'white';
            ctx.fillText('üòä', player.x * cellSize + cellSize / 2, player.y * cellSize + cellSize / 2);
        }

        // D√©placer le joueur
        function movePlayer(direction) {
            const directions = {
                up: [0, -1, 0],
                right: [1, 0, 1],
                down: [0, 1, 2],
                left: [-1, 0, 3]
            };

            const [dx, dy, dir] = directions[direction];
            
            if (!maze[player.y][player.x].walls[dir]) {
                player.x += dx;
                player.y += dy;
                steps++;
                document.getElementById('steps').textContent = steps;
                
                showingHint = false;
                calculatePath();
                draw();

                if (player.x === exit.x && player.y === exit.y) {
                    clearInterval(timerInterval);
                    setTimeout(showVictory, 500);
                }
            }
        }

        // Contr√¥les clavier
        document.addEventListener('keydown', (e) => {
            const keyMap = {
                'ArrowUp': 'up',
                'ArrowDown': 'down',
                'ArrowLeft': 'left',
                'ArrowRight': 'right',
                'z': 'up',
                'Z': 'up',
                's': 'down',
                'S': 'down',
                'q': 'left',
                'Q': 'left',
                'd': 'right',
                'D': 'right'
            };

            if (keyMap[e.key]) {
                e.preventDefault();
                movePlayer(keyMap[e.key]);
            }
        });

        // Afficher un indice
        function showHint() {
            showingHint = true;
            draw();
            setTimeout(() => {
                showingHint = false;
                draw();
            }, 3000);
        }

        // Afficher la victoire
        function showVictory() {
            let stars = '‚≠ê‚≠ê‚≠ê';
            const optimalSteps = path.length - 1;
            
            if (steps > optimalSteps * 1.5) stars = '‚≠ê‚≠ê';
            if (steps > optimalSteps * 2) stars = '‚≠ê';

            document.getElementById('stars').textContent = stars;
            document.getElementById('final-steps').textContent = steps;
            document.getElementById('final-time').textContent = timer + 's';
            document.getElementById('victory-modal').style.display = 'flex';
        }

        // Niveau suivant
        function nextLevel() {
            level++;
            document.getElementById('level').textContent = level;
            document.getElementById('victory-modal').style.display = 'none';
            generateNewMaze();
        }

        // Changer la difficult√©
        document.querySelectorAll('.difficulty-btn').forEach(btn => {
            btn.addEventListener('click', function() {
                document.querySelectorAll('.difficulty-btn').forEach(b => b.classList.remove('active'));
                this.classList.add('active');
                mazeSize = parseInt(this.dataset.size);
                cellSize = Math.min(30, 600 / mazeSize);
                level = 1;
                document.getElementById('level').textContent = level;
                init();
            });
        });

        // D√©marrer le jeu
        init();
    </script>
</body>
</html>